#!/usr/bin/env ruby -w
# encoding: UTF-8
需要 'HSV'
需要 'D二维点'
需要 'D圆形'
class C细胞
  包含模块 M代理控制反转
  可读属性 :名称, :质量, :半径, :颜色, :形体, :形象信息, :视野半径, :辐射强度
  def 初始化(名称 = '', 质量 = 36, 主循环间隔 = 20, 颜色 = nil, 控制器 = C细胞静止控制器.新建)
    @名称, @质量, @主循环间隔, @颜色, @控制器 = 名称, 质量, 主循环间隔, 颜色, 控制器
    @颜色 ||= 获取随机颜色
    @控制器.设置控制对象(self)
    @吞噬利用比例 = 0.8
    @辐射强度 = 1000000
    @单位时间质量消耗比例 = 0.000002#每5秒减1%
    @单位距离质量消耗比例 = 0.00001#每1000距离减1%
  end
  
  初始化执行 do
    刷新半径
    添加初始事件(C时间轴事件.新建(:主循环, 随机(100)))
    #添加初始事件(C时间轴事件.新建(:销毁, 1000 + 随机(2000)))
  end
  
  def 刷新半径
    半径 = @质量.开根.向下取整
    if @半径 != 半径
      @半径 = 半径
      半径变化回调
      追加事件(C时间轴事件.新建(:形变))
    end
  end
  def 半径变化回调
    @形体 = D圆形.新建(@半径)
    @形象信息 = C形象信息.新建(@形体, {颜色: @颜色, 名称: @名称})
    @速度 = @半径 < 25 ? 0.48678179952672035 : 2 * @半径**(-0.439)#(2200 * 半径**(-0.439)每秒)
    @视野半径 = @半径 < 16 ? 330 : 500 / (64.0 / @半径)**0.3
    @最低可感知信能强度 = @半径 < 16 ? 9 : 1000000 / @视野半径.平方
  end
  def 获取随机颜色;SCRF::HSV.新建(随机(359),0.97,255).转换为RGB.转换为hex end
  def 质量变化(数值)
    @质量 += 数值
    刷新半径
  end
  def 主循环(收到信能, 间隔时间)
    时间质量消耗(间隔时间)
    可感知信能 = 感知判断(收到信能)
    @同感者.获得感知(可感知信能) if @同感者
    移动方向 = @控制器.判断移动方向(可感知信能)
    移动(移动方向, @主循环间隔 - 1) if 移动方向
    追加事件(C时间轴事件.新建(:主循环, @主循环间隔))
  end
  def 移动(移动方向, 移动时间)
    移动向量 = 移动方向 * @速度 * 移动时间
    移动距离 = 移动向量.模
    if 移动距离 > 5.0
      单位时间移动向量 = 移动向量 / 移动时间.浮点化
      移动时间数组 = 移动时间.均匀划分((移动距离 / 5.0).向上取整)
      追加事件(C时间轴事件.新建(:均匀移动, 移动时间数组[-1], [移动时间数组, 单位时间移动向量]))
    else
      追加事件(C时间轴事件.新建(:移动, 移动时间, 移动向量))
    end
  end
  def 吞噬(细胞);吞噬判断(细胞).自己{|是否吞噬| 进行吞噬(细胞) if 是否吞噬} end
  def 吞噬判断(细胞);true end
  def 进行吞噬(细胞);质量变化(细胞.质量 * @吞噬利用比例) end
  def 时间质量消耗(间隔时间);质量变化(-@单位时间质量消耗比例 * @质量 * 间隔时间) if @质量 > 50 end
  def 移动质量消耗(移动距离);质量变化(-@单位距离质量消耗比例 * @质量 * 移动距离) if @质量 > 50 end
  def 感知判断(信能数组)
    信能数组.找出全部 do |信能|
      case 信能
      when C带来源信能
        信能.能量.强度 > @最低可感知信能强度
      else
        true
      end
    end
  end
  def 设置同感者(同感者);@同感者 = 同感者 end
  def 字符串;"细胞: #{@名称}" end
end

描述 C细胞 do
  添加测试 '细胞半径测试' do
    期望(C细胞.新建('', 150).半径).等于 12
  end
end
